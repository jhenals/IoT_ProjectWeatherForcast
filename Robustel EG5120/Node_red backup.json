[{"id":"c8c6253ee446d88e","type":"modbus-read","z":"39313ea590edc1f8","name":"","topic":"","showStatusActivities":false,"logIOActivities":false,"showErrors":false,"showWarnings":false,"unitid":"1","dataType":"HoldingRegister","adr":"0x100","quantity":"20","rate":"10","rateUnit":"s","delayOnStart":false,"startDelayTime":"","server":"f8dd83bd994476d2","useIOFile":false,"ioFile":"","useIOForPayload":false,"emptyMsgOnFail":true,"x":150,"y":120,"wires":[["cb06b79ac5aac55a"],[]]},{"id":"1e853f7131d5eed5","type":"debug","z":"39313ea590edc1f8","name":"debug 2","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"payload","targetType":"msg","statusVal":"","statusType":"auto","x":1300,"y":160,"wires":[]},{"id":"cb06b79ac5aac55a","type":"function","z":"39313ea590edc1f8","name":"postprocessing","func":"let device_id = 101\nfunction uint32ToFloat(num) {\n    let buffer = new ArrayBuffer(4);\n    let intView = new Uint32Array(buffer);\n    let floatView = new Float32Array(buffer);\n    intView[0] = num;\n    var floatNumber = floatView[0];\n    return floatNumber;\n}\n\nconst dataDict = {\n    temperature: { offset: 0, wsize: 1, hookFn: (data) => { return data / 100 } },\n    humidity: { offset: 1, wsize: 1 },\n    light: { offset: 2, wsize: 1 },\n    noise: { offset: 3, wsize: 1 },\n    pressure: { offset: 4, wsize: 2, hookFn: uint32ToFloat },\n    tof: { offset: 6, wsize: 1 },\n    angle: { offset: 7, wsize: 1 },\n    accX: { offset: 8, wsize: 2, hookFn: uint32ToFloat },\n    accY: { offset: 10, wsize: 2, hookFn: uint32ToFloat },\n    accZ: { offset: 12, wsize: 2, hookFn: uint32ToFloat },\n    vibrAccX: { offset: 14, wsize: 2, hookFn: uint32ToFloat },\n    vibrAccY: { offset: 16, wsize: 2, hookFn: uint32ToFloat },\n    vibrAccZ: { offset: 18, wsize: 2, hookFn: uint32ToFloat },\n}\n\nfunction pasreData(arr, attrName, offset, wsize, hookFn) {\n    let value = null;\n    if (arr.length >= (offset + wsize)) {\n        if (wsize == 1) {\n            value = arr[offset];\n        } else if (wsize == 2) {\n            let lword = arr[offset] & 0xFFFF;\n            let hword = arr[offset + 1] & 0xFFFF;\n            value = (hword << 16) | lword;\n        } else {\n            return null;\n        }\n        if (hookFn) {\n            value = hookFn(value)\n        }\n    }\n    return value;\n}\n\nfunction processPayload(msg) {\n    if (Array.isArray(msg.payload)) {\n        let payload = { device_id: device_id };\n\n        \n        let arr = msg.payload;\n        for (let key in dataDict) {\n            payload[key] =\n                pasreData(arr,\n                    key,\n                    dataDict[key].offset,\n                    dataDict[key].wsize,\n                    dataDict[key].hookFn);\n        }\n        msg.payload = payload;\n    }\n    return msg;\n}\n\nreturn processPayload(msg);","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":360,"y":120,"wires":[["749f0f6be07c96ae"]]},{"id":"749f0f6be07c96ae","type":"function","z":"39313ea590edc1f8","name":"Prepare ML Input","func":"// Store full sensor data for later merging\nflow.set('current_sensor_data', msg.payload);\n\n// Create ML input with only required fields\nlet mlInput = {\n    temperature: msg.payload.temperature,\n    humidity: msg.payload.humidity,\n    pressure: msg.payload.pressure,\n    tof: msg.payload.tof\n};\n\n// Format as JSON string for Python script\n// Use top-level keys, no 'mlInput' nesting\nmsg.payload = `'${JSON.stringify(mlInput)}'`;\nreturn msg;\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":170,"y":220,"wires":[["b9e590e1bd2d8f98"]]},{"id":"b9e590e1bd2d8f98","type":"exec","z":"39313ea590edc1f8","command":"/home/admin1/weather_ML/venv/bin/python3 /home/admin1/weather_ML/predictor.py","addpay":"payload","append":"","useSpawn":"false","timer":"","winHide":false,"oldrc":false,"name":"ML Weather Predictor","x":400,"y":220,"wires":[["13dde89ae8944146"],["40b250eb8f0af5c7"],["7362525b8d312d4d"]]},{"id":"40b250eb8f0af5c7","type":"debug","z":"39313ea590edc1f8","name":"ML Errors","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"payload","targetType":"msg","statusVal":"","statusType":"auto","x":640,"y":220,"wires":[]},{"id":"13dde89ae8944146","type":"function","z":"39313ea590edc1f8","name":"Merge Prediction with Sensor Data","func":"// Get the original sensor data\nlet sensorData = flow.get('current_sensor_data');\n\n// Parse ML prediction result\ntry {\n    let prediction = JSON.parse(msg.payload);\n    \n    // Merge prediction with sensor data\n    msg.payload = {\n        ...sensorData,\n        weather_prediction: prediction.prediction,\n        prediction_confidence: prediction.confidence,\n        prediction_timestamp: new Date().toISOString()\n    };\n    \n    // Also include all probabilities for detailed analysis\n    if (prediction.probabilities) {\n        msg.payload.weather_probabilities = prediction.probabilities;\n    }\n    \n    return msg;\n    \n} catch (e) {\n    node.error(\"Failed to parse ML prediction: \" + e.message);\n    // Return sensor data without prediction\n    msg.payload = sensorData;\n    msg.payload.weather_prediction = \"ERROR\";\n    msg.payload.prediction_confidence = 0;\n    return msg;\n}","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":720,"y":160,"wires":[["aed66183772f94ac"]]},{"id":"5aea4dc22b54fecc","type":"comment","z":"39313ea590edc1f8","name":"Weather Data from S6000U sensor with ML Prediction","info":"- Gather data from Robustel EG5120 gateway using Modbus\n- Preprocess the data using function\n- Apply TensorFlow Lite ML for weather prediction\n- Send final data with predictions to Database","x":360,"y":60,"wires":[]},{"id":"5dbb95165422ba3b","type":"inject","z":"39313ea590edc1f8","name":"Query every 5 min","props":[{"p":"payload"}],"repeat":"20","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"","payloadType":"date","x":270,"y":580,"wires":[["f29fec14b1beb127"]]},{"id":"209f567420cab3c8","type":"function","z":"39313ea590edc1f8","name":"Format for Cloud","func":"let data = {};\n\n// Ensure we have a payload to work with\nif (Array.isArray(msg.payload)) {\n    msg.payload.forEach(record => {\n        switch (record._field) {\n            case 'latitude': data.latitude = record._value; break;\n            case 'longitude': data.longitude = record._value; break;\n            case 'status': data.status = record._value; break;\n            case 'temperature': data.temperature = record._value; break;\n            case 'humidity': data.humidity = record._value; break;\n            case 'light': data.light = record._value; break;\n            case 'noise': data.noise = record._value; break;\n            case 'pressure': data.pressure = record._value; break;\n            case 'tof': data.tof = record._value; break;\n            case 'angle': data.angle = record._value; break;\n            case 'accX': data.accX = record._value; break;\n            case 'accY': data.accY = record._value; break;\n            case 'accZ': data.accZ = record._value; break;\n            case 'vibrAccX': data.vibrAccX = record._value; break;\n            case 'vibrAccY': data.vibrAccY = record._value; break;\n            case 'vibrAccZ': data.vibrAccZ = record._value; break;\n            // ML Prediction fields\n            case 'weather_prediction': data.weather_prediction = record._value; break;\n            case 'prediction_confidence': data.prediction_confidence = record._value; break;\n            case 'prediction_timestamp': data.prediction_timestamp = record._value; break;\n            // Catch-all for any other fields\n            default: data[record._field] = record._value; break;\n        }\n    });\n} else if (msg.payload && msg.payload._field) {\n    // Single record format handling\n    data[msg.payload._field] = msg.payload._value;\n}\n\n// Fixed metadata\ndata.device_id = 101;\n\n// Reassign and return\nmsg.payload = data;\nreturn msg;","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":710,"y":580,"wires":[["cb8a2abec8d1a0e5","5941af8d9ef1b4a5"]]},{"id":"cb8a2abec8d1a0e5","type":"influxdb out","z":"39313ea590edc1f8","influxdb":"fc05c283d7ec5771","name":"InfluxDB Cloud","measurement":"Sensor_S6000U_data2","precision":"ms","retentionPolicy":"","database":"","precisionV18FluxV20":"ms","retentionPolicyV18Flux":"","org":"90fe5af1cd03eaf7","bucket":"Weather_data","x":960,"y":640,"wires":[]},{"id":"593cf148c4b489ca","type":"debug","z":"39313ea590edc1f8","name":"Query Result","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"payload","targetType":"msg","statusVal":"","statusType":"auto","x":690,"y":500,"wires":[]},{"id":"5941af8d9ef1b4a5","type":"debug","z":"39313ea590edc1f8","name":"Cloud Data","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"payload","targetType":"msg","x":950,"y":520,"wires":[]},{"id":"7ad9e22669f483fe","type":"comment","z":"39313ea590edc1f8","name":"Weather data forecast with ML and cloud sync","info":"Sensor data → ML prediction → Local DB → Cloud DB","x":470,"y":440,"wires":[]},{"id":"85c50244d49766e7","type":"robustel-influxdb out","z":"39313ea590edc1f8","name":"Database","measurement":"S6000U_measurements","precision":"","retentionPolicy":"","database":"database","precisionV18FluxV20":"ms","retentionPolicyV18Flux":"","bucket":"bucket","x":1320,"y":260,"wires":[]},{"id":"ac203db5aa53b9a5","type":"function","z":"39313ea590edc1f8","name":"NMEA to Decimal Degrees","func":"var line = msg.payload;\nif (line.includes(\"RMC\")) {\n    var p = line.split(\",\");\n    if (p[2] === \"A\") { // Check for valid fix\n        \n        function toDecimal(coord, dir) {\n            var dot = coord.indexOf(\".\");\n            var deg = parseFloat(coord.substring(0, dot - 2));\n            var min = parseFloat(coord.substring(dot - 2));\n            var res = deg + (min / 60);\n            if (dir === \"S\" || dir === \"W\") res = -res;\n            return parseFloat(res.toFixed(6));\n        }\n\n        var newLat = toDecimal(p[3], p[4]);\n        var newLon = toDecimal(p[5], p[6]);\n\n        // 1. Get the last known position from flow memory\n        var lastPos = flow.get(\"lastKnownPos\") || { lat: 0, lon: 0 };\n\n        // 2. Calculate the difference (Roughly 0.0001 degrees is ~11 meters)\n        var latDiff = Math.abs(newLat - lastPos.lat);\n        var lonDiff = Math.abs(newLon - lastPos.lon);\n\n        // 3. Only update if the change is significant (filtering stationary drift)\n        if (latDiff > 0.0001 || lonDiff > 0.0001) {\n            flow.set(\"lastKnownPos\", { lat: newLat, lon: newLon });\n            \n            msg.payload = {\n                latitude: newLat,\n                longitude: newLon,\n                status: \"Moving\"\n            };\n            return msg;\n        } else {\n            // Optional: Still output the data but mark it as stationary\n            msg.payload = {\n                latitude: lastPos.lat,\n                longitude: lastPos.lon,\n                status: \"Stationary\"\n            };\n            return msg;\n        }\n    }\n}\nreturn null;","outputs":1,"timeout":"0","noerr":0,"initialize":"","finalize":"","libs":[],"x":560,"y":360,"wires":[["0230a4e0238a4e43","aed66183772f94ac"]]},{"id":"070a015f6a6086b9","type":"tcp in","z":"39313ea590edc1f8","name":"Robustel GPS Source","server":"client","host":"127.0.0.1","port":"12345","datamode":"stream","datatype":"utf8","newline":"\\n","topic":"","trim":false,"base64":false,"tls":"","x":180,"y":360,"wires":[["ac203db5aa53b9a5"]]},{"id":"0230a4e0238a4e43","type":"OpcUa-Item","z":"39313ea590edc1f8","item":"ns=1;s=EG5120.GPS.Coordinates","datatype":"String","value":"","name":"Map to OPC UA","x":940,"y":420,"wires":[["69d5f5a1cba1ae0e"]]},{"id":"aed66183772f94ac","type":"join","z":"39313ea590edc1f8","name":"Merge Sensor & GPS","mode":"custom","build":"merged","property":"payload","propertyType":"msg","key":"topic","joiner":"\\n","joinerType":"str","accumulate":true,"timeout":"","count":"2","reduceRight":false,"reduceExp":"","reduceInit":"","reduceInitType":"","reduceFixup":"","x":1070,"y":220,"wires":[["85c50244d49766e7","1e853f7131d5eed5"]]},{"id":"69d5f5a1cba1ae0e","type":"OpcUa-Server","z":"39313ea590edc1f8","port":"4840","name":"Robustel_UA_Server","endpoint":"/UA/Robustel","users":"","nodesetDir":"","autoAcceptUnknownCertificate":false,"registerToDiscovery":false,"constructDefaultAddressSpace":false,"allowAnonymous":false,"endpointNone":false,"endpointSign":false,"endpointSignEncrypt":false,"endpointBasic128Rsa15":false,"endpointBasic256":false,"endpointBasic256Sha256":false,"maxNodesPerBrowse":"","maxNodesPerHistoryReadData":"","maxNodesPerHistoryReadEvents":"","maxNodesPerHistoryUpdateData":"","maxNodesPerRead":"","maxNodesPerWrite":"","maxNodesPerMethodCall":"","maxNodesPerRegisterNodes":"","maxNodesPerNodeManagement":"","maxMonitoredItemsPerCall":"","maxNodesPerHistoryUpdateEvents":"","maxNodesPerTranslateBrowsePathsToNodeIds":"","maxConnectionsPerEndpoint":"","maxMessageSize":"","maxBufferSize":"","maxSessions":"","x":1260,"y":420,"wires":[[]]},{"id":"f29fec14b1beb127","type":"robustel-influxdb in","z":"39313ea590edc1f8","name":"Read Local DB","query":"from(bucket: \"bucket\")\n  |> range(start: -5m)\n  |> filter(fn: (r) => r._measurement == \"S6000U_measurements\")\n  |> last()","rawOutput":false,"precision":"","retentionPolicy":"","org":"organisation","x":480,"y":580,"wires":[["209f567420cab3c8","593cf148c4b489ca"]]},{"id":"7362525b8d312d4d","type":"debug","z":"39313ea590edc1f8","name":"debug 3","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","statusVal":"","statusType":"auto","x":640,"y":280,"wires":[]},{"id":"f8dd83bd994476d2","type":"modbus-client","name":"","clienttype":"serial","bufferCommands":true,"stateLogEnabled":true,"queueLogEnabled":false,"failureLogEnabled":true,"tcpHost":"127.0.0.1","tcpPort":"502","tcpType":"DEFAULT","serialPort":"/dev/ttyCOM1","serialType":"RTU","serialBaudrate":"115200","serialDatabits":"8","serialStopbits":"1","serialParity":"none","serialConnectionDelay":"1000","serialAsciiResponseStartDelimiter":"0x3A","unit_id":1,"commandDelay":1,"clientTimeout":1000,"reconnectOnTimeout":false,"reconnectTimeout":1000,"parallelUnitIdsAllowed":false,"showErrors":true,"showWarnings":true,"showLogs":true},{"id":"fc05c283d7ec5771","type":"influxdb","hostname":"us-east-1-1.aws.cloud2.influxdata.com","port":"443","protocol":"https","database":"","name":"InfluxDB Cloud","usetls":true,"tls":"","influxdbVersion":"2.0","url":"https://us-east-1-1.aws.cloud2.influxdata.com","timeout":"","rejectUnauthorized":true}]